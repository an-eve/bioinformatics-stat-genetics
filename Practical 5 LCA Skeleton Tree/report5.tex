\documentclass[12 pt,a4paper]{article}
\usepackage{listings}
\usepackage{mathptmx}
\usepackage{savetrees}
\usepackage{minted}
\title{Practical 5:  LCA Skeleton Tree}
\author{Anna Putina and Marine Mazeau}
\date{17/10/2023, submission deadline 23/10/2023}
\begin{document}
\maketitle
The code below will be used in every questions. It reads the data and creates the graph, and then the restricted graph which we will be working on.
\setminted{autogobble=true, breaklines=true}
\begin{minted}{python}
import networkx as nx
import pandas as pd
import matplotlib.pyplot as plt

# Read the data
file_path = "nodes.dmp"
df = pd.read_csv(file_path, delimiter = r"\s+\|\s+", usecols=[0, 1, 2], engine = "python", header=None, names = ["child", "parent", "rank"]) 
attrs = dict(zip(df['child'], df['rank']))

# Create the graph
G = nx.from_pandas_edgelist(df, source='parent', target='child', create_using=nx.DiGraph())
nx.set_node_attributes(G, attrs, name="rank")

# Remove self-loops
G.remove_edge(1,1)

#----------------------------------------------------------------------------

# Create the restricted graph that represents the NCBI taxonomy
valid_ranks = ["superkingdom", "phylum", "class", "order", "family", "genus", "species"]

# Nodes to remove
not_nodes = [node for node, attrs in G.nodes(data=True) if not attrs['rank'] in valid_ranks]

restricted_taxonomy = G.copy()
restricted_taxonomy.add_edge(1,1)

def delete_nodes_preserve_neighbors(graph, nodes_to_delete):
    for node in nodes_to_delete:
        list_succes = list(graph.successors(node)) 
        list_pred = list(graph.predecessors(node))
        if node != 1:
            graph.remove_node(node)
        for source in list_pred:
            for target in list_succes:
                if source != target and not graph.has_edge(source, target):
                    graph.add_edge(source, target)


delete_nodes_preserve_neighbors(restricted_taxonomy, not_nodes)
restricted_taxonomy.remove_edge(1,1)
\end{minted}
\newpage
\begin{enumerate}
\item
\setminted{autogobble=true, breaklines=true}
\begin{minted}{python}
# Read the mappings of sequence reads to NCBI taxonomic identifiers
mapping_file = 'mapping.txt'
mapping = {}

with open(mapping_file, 'r') as file:
    for line in file:
        parts = line.strip().split()
        read_id = parts[0]
        taxonomic_nodes = [int(node) for node in parts[1:]]  # Convert nodes to integers
        mapping[read_id] = taxonomic_nodes

# Define a function to find the full lineage of a taxonomic node
def find_full_lineage(taxonomy_graph, node):
    lineage = []
    while node in taxonomy_graph:
        lineage.append(node)
        parents = list(taxonomy_graph.predecessors(node))
        if not parents:
            break
        node = parents[0]
    return lineage

# Full lineage of every node of every readID is stored in the dictionnary lineages
lineages = {}
for read_id, taxonomic_nodes in mapping.items():
    seq = []
    for node in taxonomic_nodes:
        full_lineage = find_full_lineage(restricted_taxonomy, node)
        full_lineage.reverse()
        seq.append(full_lineage)
    lineages[read_id] = seq
\end{minted}
The full lineage of every node of every readID is stored in the dictionnary "lineages".
\item
\begin{minted}{python}
# LCAs for each read
LCAs = {}
for read_id, seq in lineages.items():
    min_length = min(len(lst) for lst in seq) 
    lst1 = seq[0]
    all_same = all(lst1[0] == lst[0] for lst in seq[1:]) #this value is always True (the root)
    i = 0
    while all_same and (i+1) < min_length:
        LCAs[read_id] = lst1[i]
        all_same = all(lst1[i+1] == lst[i+1] for lst in seq[1:])

print("{The LCAs for each read: \n", LCAs)
\end{minted}
The LCA for each read is the root.
\item 
\item 
All the skeletons are stored in the dictionnary "Skeletons". They are DiGraphs.
\begin{minted}{python}
# LCA skeletons for each sequence read
Skeletons = {}
for read_id, seq in lineages.items():
    # Create a set of all unique nodes
    all_nodes = {item for sublist in seq for item in sublist}

    # Construct a directed graph (DAG)
    G = nx.DiGraph()
    G.add_nodes_from(all_nodes)

    # Connect nodes in the lineages
    for lineage in seq:
        for i in range(len(lineage) - 1):
            G.add_edge(lineage[i], lineage[i+1])
    Skeletons[read_id] = G
    # The number of nodes
    print(f"For the {read_id} sequence read: ")
    print('The number of nodes: ', Skeletons[read_id].number_of_nodes())
\end{minted}
\item 
The number of nodes in each LCA skeleton was printed in previous question in the loop where the skeleton (graph) was created. Here are the results : \\
- For the R00010 sequence read: 47 nodes \\
- For the R00020 sequence read: 85 nodes \\
- For the R00030 sequence read: 130 nodes \\
- For the R00040 sequence read: 154 nodes \\
- For the R00050 sequence read: 201 nodes \\
- For the R00060 sequence read: 214 nodes\\
- For the R00070 sequence read: 266 nodes\\
- For the R00080 sequence read: 283 nodes \\
- For the R00090 sequence read: 305 nodes \\
- For the R00100 sequence read: 344 nodes \\

\item Same answer as in question 2 : the root is the LCA for all sequence reads. 
\end {enumerate}
\end{document}